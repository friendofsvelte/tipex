{
  "basicEditorSetup": "// Get editor reference\nlet editor: Editor;\n\n// In your component\n<Tipex bind:tipex={editor} />\n\n// Now you can use commands\neditor.commands.setContent('<p>Hello World</p>')",
  
  "contentManagement": "// Set entire editor content\neditor.commands.setContent('<p>Hello World</p>')\neditor.commands.setContent(htmlString, true) // true to emit update event\n\n// Insert content at current cursor position\neditor.commands.insertContent('New content')\neditor.commands.insertContent('<p>HTML content</p>')\n\n// Insert content at specific position\neditor.commands.insertContentAt(10, 'Content at position 10')\n\n// Clear all content\neditor.commands.clearContent()\neditor.commands.clearContent(true) // true to emit update event\n\n// Focus the editor\neditor.commands.focus()\neditor.commands.focus('start') // Focus at start\neditor.commands.focus('end')   // Focus at end\neditor.commands.focus(10)      // Focus at specific position\n\n// Blur (unfocus) the editor\neditor.commands.blur()",
  
  "textFormatting": "// Basic formatting toggles (all available in enhanced Controls)\neditor.commands.toggleBold()\neditor.commands.toggleItalic()\neditor.commands.toggleUnderline()  // Now supported with extension\neditor.commands.toggleStrike()\neditor.commands.toggleCode()\n\n// Set formatting (without toggle)\neditor.commands.setBold()\neditor.commands.setItalic()\neditor.commands.setUnderline()\neditor.commands.unsetBold()\neditor.commands.unsetItalic()\neditor.commands.unsetUnderline()\n\n// Heading management (H1, H2, H3 buttons available)\neditor.commands.toggleHeading({ level: 1 })\neditor.commands.toggleHeading({ level: 2 })\neditor.commands.toggleHeading({ level: 3 })\neditor.commands.setHeading({ level: 1 })\neditor.commands.unsetHeading()\n\n// Paragraph operations\neditor.commands.setParagraph()\n\n// Check active formatting states\nconst isBold = editor.isActive('bold')\nconst isItalic = editor.isActive('italic')\nconst isUnderline = editor.isActive('underline')\nconst isH1 = editor.isActive('heading', { level: 1 })\nconst isH2 = editor.isActive('heading', { level: 2 })",
  
  "listManagement": "// Toggle list types (all available in enhanced Controls)\neditor.commands.toggleBulletList()    // Bullet list button\neditor.commands.toggleOrderedList()   // Numbered list button  \neditor.commands.toggleTaskList()      // Task list button\n\n// Set specific list types\neditor.commands.setBulletList()\neditor.commands.setOrderedList()\neditor.commands.setTaskList()\n\n// List item operations\neditor.commands.splitListItem('listItem')\neditor.commands.sinkListItem('listItem')  // Indent\neditor.commands.liftListItem('listItem')  // Outdent\n\n// Task list specific\neditor.commands.toggleTask()\neditor.commands.setTaskList()\n\n// Check active list states\nconst isBulletList = editor.isActive('bulletList')\nconst isOrderedList = editor.isActive('orderedList')\nconst isTaskList = editor.isActive('taskList')\n\n// Example: Smart list button with state\nfunction createListButton(listType: 'bulletList' | 'orderedList' | 'taskList') {\n    return {\n        isActive: () => editor.isActive(listType),\n        toggle: () => {\n            switch(listType) {\n                case 'bulletList':\n                    editor.chain().focus().toggleBulletList().run()\n                    break\n                case 'orderedList':\n                    editor.chain().focus().toggleOrderedList().run()\n                    break\n                case 'taskList':\n                    editor.chain().focus().toggleTaskList().run()\n                    break\n            }\n        }\n    }\n}",
  
  "linkManagement": "// Basic link operations\neditor.commands.setLink({ href: 'https://example.com' })\neditor.commands.setLink({ \n    href: 'https://example.com',\n    target: '_blank',\n    rel: 'noopener noreferrer'\n})\neditor.commands.unsetLink()\n\n// Advanced link handling with validation\nfunction setLinkWithValidation(url: string, text?: string) {\n    // Validate URL\n    if (!url.startsWith('http://') && !url.startsWith('https://')) {\n        url = 'https://' + url\n    }\n    \n    try {\n        new URL(url) // Validate URL format\n        \n        if (text) {\n            // Insert text with link\n            editor.chain()\n                .focus()\n                .insertContent(`<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${text}</a>`)\n                .run()\n        } else {\n            // Apply link to selection\n            editor.chain()\n                .focus()\n                .setLink({ \n                    href: url, \n                    target: '_blank', \n                    rel: 'noopener noreferrer' \n                })\n                .run()\n        }\n    } catch (error) {\n        console.error('Invalid URL:', url)\n    }\n}\n\n// Check if current selection/cursor is in a link\nconst isLinkActive = editor.isActive('link')\nconst linkAttributes = editor.getAttributes('link') // Get href, target, etc.",
  
  "imageHandling": "// Basic image insertion\neditor.commands.setImage({\n    src: 'https://example.com/image.jpg',\n    alt: 'Description',\n    title: 'Image title'\n})\n\n// Handle file uploads with validation\nasync function handleImageUpload(file: File) {\n    // Validate file type\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']\n    if (!allowedTypes.includes(file.type)) {\n        throw new Error('Unsupported file type')\n    }\n    \n    // Validate file size (e.g., 5MB limit)\n    const maxSize = 5 * 1024 * 1024\n    if (file.size > maxSize) {\n        throw new Error('File too large')\n    }\n    \n    try {\n        // Option 1: Upload to server\n        const formData = new FormData()\n        formData.append('image', file)\n        \n        const response = await fetch('/api/upload', {\n            method: 'POST',\n            body: formData\n        })\n        \n        if (!response.ok) throw new Error('Upload failed')\n        \n        const { url, alt } = await response.json()\n        \n        editor.commands.setImage({\n            src: url,\n            alt: alt || file.name,\n            title: file.name\n        })\n        \n    } catch (error) {\n        console.error('Image upload failed:', error)\n        \n        // Option 2: Fallback to base64 for small images\n        if (file.size < 1024 * 1024) { // 1MB limit for base64\n            const reader = new FileReader()\n            reader.onload = (e) => {\n                editor.commands.setImage({\n                    src: e.target?.result as string,\n                    alt: file.name,\n                    title: file.name\n                })\n            }\n            reader.readAsDataURL(file)\n        }\n    }\n}\n\n// Handle paste events for images\neditor.on('paste', (event) => {\n    const items = event.clipboardData?.items\n    if (!items) return\n    \n    for (const item of items) {\n        if (item.type.startsWith('image/')) {\n            const file = item.getAsFile()\n            if (file) {\n                handleImageUpload(file)\n                event.preventDefault()\n            }\n        }\n    }\n})",
  

  "blockElements": "// Block elements (all available in enhanced Controls)\neditor.commands.toggleBlockquote()     // Quote button\neditor.commands.toggleCodeBlock()      // Code block button\neditor.commands.setHorizontalRule()    // Horizontal rule button\n\n// Set specific block types\neditor.commands.setBlockquote()\neditor.commands.setCodeBlock()\neditor.commands.setCodeBlock({ language: 'javascript' })\n\n// Check active block states\nconst isBlockquote = editor.isActive('blockquote')\nconst isCodeBlock = editor.isActive('codeBlock')\n\n// Advanced block operations\neditor.commands.wrapIn('blockquote')\neditor.commands.lift('blockquote')\n\n// Insert dividers and breaks\neditor.commands.setHorizontalRule()\neditor.commands.setHardBreak()\n\n// Code block with language\neditor.chain()\n    .focus()\n    .toggleCodeBlock({ language: 'typescript' })\n    .run()",
  
  "selectionManagement": "// Selection operations\neditor.commands.selectAll()\neditor.commands.selectTextblockStart()\neditor.commands.selectTextblockEnd()\neditor.commands.selectNodeForward()\neditor.commands.selectNodeBackward()\n\n// Set selection to specific range\neditor.commands.setTextSelection({ from: 0, to: 10 })\neditor.commands.setTextSelection(5) // Set cursor at position 5\n\n// Delete operations\neditor.commands.deleteSelection()\neditor.commands.deleteRange({ from: 0, to: 10 })\neditor.commands.deleteCurrentNode()\n\n// Navigation\neditor.commands.goToNext()\neditor.commands.goToPrevious()",

  "historyManagement": "// Undo/Redo operations (buttons available in enhanced Controls)\neditor.commands.undo()    // Undo button with smart disabled state\neditor.commands.redo()    // Redo button with smart disabled state\n\n// Check if undo/redo is available\nconst canUndo = editor.can().undo()\nconst canRedo = editor.can().redo()\n\n// Clear history\neditor.commands.clearHistory()\n\n// The enhanced Controls component automatically handles:\n// - Button disabled states based on availability\n// - Visual feedback for enabled/disabled buttons\n// - Proper ARIA labels for accessibility\n\n// Custom undo/redo buttons (if building custom controls)\nfunction createHistoryButton(type: 'undo' | 'redo') {\n    return {\n        canExecute: () => type === 'undo' ? editor.can().undo() : editor.can().redo(),\n        execute: () => type === 'undo' ? editor.commands.undo() : editor.commands.redo(),\n        isDisabled: () => type === 'undo' ? !editor.can().undo() : !editor.can().redo()\n    }\n}",
  
  "advancedCommands": "// Command chaining for complex operations\neditor.chain()\n    .focus()\n    .toggleBold()\n    .toggleItalic()\n    .setTextAlign('center')\n    .run()\n\n// Conditional command execution\nif (editor.isActive('bold')) {\n    editor.chain().focus().unsetBold().setItalic().run()\n} else {\n    editor.chain().focus().setBold().run()\n}\n\n// Check if command can be executed\nconst canToggleBold = editor.can().toggleBold()\nconst canSetHeading = editor.can().setHeading({ level: 2 })\n\n// Custom command wrapper with error handling\nfunction safeCommand(command: () => boolean) {\n    try {\n        const result = command()\n        if (!result) {\n            console.warn('Command execution failed')\n        }\n        return result\n    } catch (error) {\n        console.error('Command error:', error)\n        return false\n    }\n}\n\n// Usage\nsafeCommand(() => editor.chain().focus().toggleBold().run())\n\n// Batch operations with transaction\neditor.chain()\n    .command(({ tr }) => {\n        // Custom transaction operations\n        tr.insertText('Hello')\n        tr.addMark(0, 5, editor.schema.marks.bold.create())\n        return true\n    })\n    .run()",
  
  "customCommands": "// Define custom command\nconst customCommand = () => ({ commands }: { commands: any }) => {\n    return commands.insertContent('Custom content inserted!')\n}\n\n// Register and use custom command\neditor.commands.customCommand = customCommand()\neditor.commands.customCommand()\n\n// More complex custom command\nconst insertCurrentDate = () => ({ commands }: { commands: any }) => {\n    const date = new Date().toLocaleDateString()\n    return commands.insertContent(`<p>Today is ${date}</p>`)\n}\n\n// Smart formatting command\nconst smartFormat = (text: string) => ({ commands }: { commands: any }) => {\n    // Auto-detect and apply formatting\n    if (text.startsWith('# ')) {\n        return commands.setHeading({ level: 1 })\n    } else if (text.startsWith('## ')) {\n        return commands.setHeading({ level: 2 })\n    } else if (text.startsWith('- ')) {\n        return commands.setBulletList()\n    }\n    return commands.setParagraph()\n}",
  
  "eventDrivenCommands": "// Listen to editor events and execute commands\neditor.on('update', ({ editor }) => {\n    // Auto-save functionality\n    const content = editor.getHTML()\n    localStorage.setItem('editor-content', content)\n})\n\neditor.on('selectionUpdate', ({ editor }) => {\n    // Update UI based on selection\n    const { from, to } = editor.state.selection\n    console.log(`Selection: ${from} to ${to}`)\n})\n\n// Custom keyboard shortcuts with commands\neditor.on('keydown', (event) => {\n    // Custom Ctrl+Shift+D for current date\n    if (event.ctrlKey && event.shiftKey && event.key === 'D') {\n        event.preventDefault()\n        editor.commands.insertContent(`<p>${new Date().toLocaleDateString()}</p>`)\n    }\n    \n    // Auto-format on Enter\n    if (event.key === 'Enter') {\n        const { $from } = editor.state.selection\n        const currentLine = $from.parent.textContent\n        \n        if (currentLine.startsWith('# ')) {\n            setTimeout(() => {\n                editor.commands.setHeading({ level: 1 })\n            }, 0)\n        }\n    }\n})"
}
